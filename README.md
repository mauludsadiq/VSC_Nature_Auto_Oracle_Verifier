# VSC_Nature_Auto_Oracle_Verifier
**A proof-producing, contract-verified oracle pipeline (Red → Blue) for deterministic action selection in a small “chaos environment.”**

This repository is an **automated verifier + witness generator** for a minimal agent loop:

1. A *proposer* (untrusted) emits a **Red Packet** describing a proposed step.
2. The verifier runs a fixed set of **contracts** (Percept / Model / Value / Risk / Exec).
3. The verifier emits a **Blue Bundle**: a **cryptographically auditable** set of JSON witnesses and a step-level Merkle root.
4. The loop repeats for `k = 0..N-1`.

This is the smallest “oracle” that still has the full structure you want at scale:
- **untrusted proposal**
- **contract gating**
- **deterministic selection**
- **witness artifacts**
- **step-indexed ledger**

---

## 1) What this repo does (one paragraph)
`VSC_Nature_Auto_Oracle_Verifier` consumes a sequence of untrusted step proposals (`inbox/proposal_step_k.json`) and deterministically produces a fully verified proof bundle per step (`out/stream/step_XXXXXX/`). Each step generates contract witnesses (`w_percept.json`, `w_model_contract.json`, `w_value_*.json`, `w_risk.json`, `w_exec.json`) plus an overall `bundle.json` and `root_hash.txt`. The `scripts/oracle_gamble_runner.py` runner emits a `dashboard.csv` stream so you can see pass/fail behavior over thousands of steps.

---

## 2) Repo concept: “Red” vs “Blue”
This repo is explicitly **Red/Blue separated**.

### 2.1 Red Packet (untrusted)
A **Red Packet** is an untrusted JSON proposal generated by *anything*:
- a learned model
- a scripted policy
- a human
- a random generator
- an adversary

It is named “Red” because it is **not trusted** and may contain:
- inconsistent state transitions
- forbidden next states
- invalid distributions
- fake “observations”
- action sets that don’t match risk/value tables

Red is allowed to lie.

In this repo, Red packets live here:

```
inbox/proposal_step_0.json
inbox/proposal_step_1.json
...
```

Each packet is a complete *claim* about one step of the world.

### 2.2 Blue Bundle (verified)
A **Blue Bundle** is the verifier-produced **audited record** of what the system accepted.

It is named “Blue” because it is **trusted output**:
- computed deterministically
- contract-verified
- stored as witness artifacts
- hashed into a root

Blue is not “what the model said.”
Blue is “what the system can prove.”

Blue bundles live here:

```
out/stream/step_000000/
out/stream/step_000001/
...
```

---

## 3) Why this is considered “automated”
It is “automated” in the only definition that matters:

> **Given Red inputs, the pipeline deterministically produces Blue proof artifacts without human intervention.**

Automation here means:
- No manual adjudication of correctness.
- No interpretation required to decide PASS/FAIL.
- Every claim is either proven by contract checks or rejected.

A run is fully mechanical:
- read `proposal_step_k.json`
- verify contracts
- choose / abstain
- emit witness JSONs + hashes
- append a single dashboard row

---

## 4) The step protocol (high-level)
Each step `k` has a canonical input/output shape.

### 4.1 Input: `inbox/proposal_step_k.json`
Typical fields (schema: `oracle_gamble.red_packet.v1`):

- `step_counter`
- `prev_state`, `state`
- `prev_action`
- `actions`
- `proposed_q`  (value estimates)
- `proposed_r`  (risk estimates)
- `model_row_proposal` (transition distribution proposed by Red)
- `model_row_ref` (reference transition support)
- `forbidden_next_states`
- `reward_table`
- `violation_states`
- `state_vocab`

This is the *claim*.

### 4.2 Output: `out/stream/step_XXXXXX/`
Every step writes:

- `bundle.json` (the consolidated outcome)
- `w_percept.json`
- `w_model_contract.json`
- `w_value_ABSTAIN.json` and `w_value_MOVE_RIGHT.json` (or more actions)
- `w_value.json` (summary)
- `w_risk.json`
- `w_exec.json`
- `root_hash.txt`

Plus the dashboard stream:
- `out/stream/dashboard.csv`

---

## 5) Contracts: what gets proven (and why)
The entire system is a contract stack.

Think of it as a minimal safety / correctness pipeline:

Γ = Γ_percept ∘ Γ_model ∘ Γ_value ∘ Γ_risk ∘ Γ_exec

Each contract emits:
- `inputs`
- `derived`
- `checks`
- `verdict` ∈ {PASS, FAIL}

### 5.1 Percept Contract (Γ_percept)
**Goal:** enforce that the environment observation is well-formed and consistent.

In this repo the percept layer is “multi-view”:
- you collect multiple views of the same underlying state
- you require agreement between them

Outputs:
- `checks.multiview_ok`
- `checks.format_ok`
- `checks.temporal_ok`

If percept fails, downstream reasoning is meaningless — so the pipeline is designed to **ABSTAIN**.

### 5.2 Model Contract (Γ_model)
**Goal:** verify that the proposed transition row is compatible with the sealed support / references and doesn’t enter forbidden states.

This is where “lying about dynamics” gets caught.

Model checks include:
- `support_ok` (valid distribution support)
- `pi_min_ok` (minimum probability mass constraints)
- `l1_ref_ok` (L1 distance to reference row)
- `forbid_ok` (proposed next state not forbidden)
- `l1_ver_ok` (agreement to verifier-owned transition map when present)

If model fails, the system is allowed to **reject the proposed action**.

### 5.3 Value Contract (Γ_value)
**Goal:** quantify what each action is “worth” under rollouts / Monte Carlo sampling.

Each action `a` gets a witness like:

`w_value_MOVE_RIGHT.json`:
- `mc.Q_mc`
- `mc.R_mc`
- and PASS/FAIL

### 5.4 Risk Gate (Γ_risk)
**Goal:** turn value + risk into a single action decision.

Mechanism:
- quantize `q_values` and `r_values` deterministically
- define safe set = {a : r(a) ≤ ρ_max}
- choose argmax Q over safe set
- enforce proposal consistency when `proposed_action` is provided

Important repo behavior:
- tie-breaks are deterministic
- if all Q are tied and abstain is available, **prefer ABSTAIN**

### 5.5 Exec Contract (Γ_exec)
**Goal:** verify that the action can be executed as a skill trace within constraints.

Exec checks include:
- `pre_ok` (pre-state allowed for the skill)
- `trace_len_ok`
- `subactions_ok`
- `inter_ok`
- `forbid_ok`
- `post_ok`
- `model_ok`

If exec fails, the step does not advance state.

---

## 6) Determinism and auditability
- Every contract writes a JSON witness.
- Witness JSONs are canonically serialized for stable hashing.
- Each step produces a `merkle_root` and `root_hash.txt`.

This gives you a ledger property:
- steps are immutable
- you can verify replays
- you can diff two runs by comparing roots


### 6.1 Stream integrity auditing (Ghost File Detector)
Beyond proving **Red → Blue correctness**, this repo also audits the **proof stream itself** for unexpected file drift.

`scripts/integrity_anomaly_detector.py` scans `out/stream/step_*` and flags:
- unexpected changed files (ghost writes)
- missing expected changes (silent failures)
- new files appearing / files disappearing
- forbidden phase changes (e.g., risk/percept/exec changing outside allowed windows)

It writes:
- `out/stream/integrity_anomaly_report.json`

The report is stamped so it cannot be modified without leaving a witness trail:
- `contract_sha256` (hash of the integrity contract)
- `detector_sha256` (hash of the detector script)
- `scan_first_chain_root_sha256` / `scan_last_chain_root_sha256` (chain head/tail anchors for the scanned window)

---

## 7) Requirements
- Python **3.9+**
- Git
- Optional: `rg`, `jq`

---

## 8) Clone and run (local or remote)
```bash
git clone https://github.com/mauludsadiq/VSC_Nature_Auto_Oracle_Verifier.git
cd VSC_Nature_Auto_Oracle_Verifier
python3 -m venv .venv
source .venv/bin/activate
python3 -m pip install --upgrade pip
python3 -m pip install -r requirements.txt || true
python3 -m pip install -e . || true
python3 -m pytest -q
```

---

## 9) Run the automated verifier loop
```bash
rm -rf out/stream
python3 -m scripts.oracle_gamble_runner
tail -n 20 out/stream/dashboard.csv | column -t -s,
```

---

## 10) Inspect a single step
```bash
k=9990
d="out/stream/step_$(printf "%06d" "$k")"
ls -la "$d"
jq -r '{prev_state,selected_action,observed_next_state,exec_verdict,leaf_verdicts}' "$d/bundle.json"
jq -r '{verdict,checks,inputs}' "$d/w_model_contract.json"
```


### 10.1 Verify stream integrity (Ghost File Detector)
```bash
python3 scripts/integrity_anomaly_detector.py \
  --stream-root out/stream \
  --max-steps 200 \
  --report-path out/stream/integrity_anomaly_report.json \
  --fail-on-any

jq -r "{anomalies_found,contract_sha256,detector_sha256,scan_first_chain_root_sha256,scan_last_chain_root_sha256}" \
  out/stream/integrity_anomaly_report.json
```

---

## 11) What this looks like at scale
Same structure, larger numbers:
- more states/actions
- per-action value witnesses run in parallel
- bundles stored in object storage
- lane-level roots aggregated into a global merkle tree
- replay verification and regression gating in CI

---

6. Stream integrity contract + CI gate (stream must PASS anomaly detector)
